import os
import math
import numpy as np
from copy import deepcopy

from stwcs.wcsutil import HSTWCS
from astropy.io import fits
from astropy.table import Table

from pyaxe.axeerror import aXeError

class ProjectionList:
    """
    The central class for the new object lists that will
    be generated by projecting out positions from a
    drizzled image.
    """
    def __init__(self, header_value='', dim_info=''):

        """
        Parameters
        ----------
        header_value: str
            a keyword value in the header of the
            drizzled image
        dim_info: str
            information on extra pixel rows/columns to be added
            to the 'natural' image size

        Returns
        -------
        Nothing

        Notes:
        ------
        This init-method extracts all necessary instance data
        from the input image expression in the header of the
        drizzled data. Also the dimensions of the input image
        are determined, and with together with the input parameter
        the x/y-min/max of the area allowed in the IOL is defined.
        """
        self.header_value = header_value
        self.iol_info = {}
        self.dim_info = []
        # get the information related to the IOL
        self._set_iol_info()

        # the the dimension of the input image
        self._set_indims()

        # compute the dimension information
        self._compute_diminfo(dim_info)

    def _set_iol_info(self):
        """Get all info on the extension."""

        # get the bracket information
        exte_str = self.header_value.split('.fits')[1]

        # get the inside of the brackets
        exte_data = exte_str[1:len(exte_str)-1]

        # collect fits name, extension name and extension
        # version in the dictionary
        self.iol_info['root'] = self.header_value.split('.fits')[0]
        self.iol_info['fits'] = self.header_value.split('.fits')[0] + '.fits'
        # make sure the fits file exists
        if not os.path.isfile(self.iol_info['fits']):
            err_msg = ("IOLPREP: File {0:s} does not exist!"
                       .format(self.iol_info['fits']))
            raise aXeError(err_msg)

        self.iol_info['ext_nam'] = exte_data.split(',')[0]
        self.iol_info['ext_ver'] = int(exte_data.split(',')[1])
        self.iol_name = '%s_%i.cat' % (self.iol_info['root'],
                                       self.iol_info['ext_ver'])

    def _compute_diminfo(self, dim_info):
        """Compute the absolute dimension information"""

        # possible add rows/columns on either side.
        # the '0.5' generally have to be there
        # given an image with 1000 pix, SExtractor
        # can distribute object position in [0.5, 1000.5]
        self.dim_info.append(0.5-dim_info[0])
        self.dim_info.append(0.5+dim_info[1]+self.indims[0])
        self.dim_info.append(0.5-dim_info[2])
        self.dim_info.append(0.5+dim_info[3]+self.indims[1])

    def _set_indims(self):
        """Get the input dimensions of the image"""

        in_img = fits.open(self.iol_info['fits'], 'readonly')
        in_head = in_img[self.iol_info['ext_nam'], self.iol_info['ext_ver']].header

        # extract the keywords for the image size from
        # the header
        self.indims = [in_head['NAXIS1'], in_head['NAXIS2']]
        in_img.close()
        del in_head

    def make_grismcat(self, drizzle_image=None, catalog=None):

        """Make the grism catalog.

        The method creates a new input object list. The positional
        information on objects in a drizzled image are projected
        back into the coordinate system of one input image.
        A selection is done on the basis of the projected coordinates,
        and the selected objects are stored to a new IOL file

        Parameters
        ----------
        drizzle_image : str
            The name of the large drizzled image the master catalog
            was made from
        catalog : astropy.table.Table
            A copy of the master catalog which will be edited
            and then saved

        Returns
        -------
        Nothing

        """
        if drizzle_image is None:
            raise aXeError("No drizzle image specified to make_grismcat")

        if catalog is None:
            raise aXeError("No input catalog provided for make_grismcat")

        print("\n >>>> Working on Input Object List: {0:s} >>>>\n"
              .format(self.iol_name))

        # now translate ra dec to new image pixel points
        dither_image_wcs = HSTWCS(self.header_value)
        dither_image_xy = dither_image_wcs.all_world2pix(catalog['X_WORLD'],
                                                         catalog['Y_WORLD'], 1)
        # calculate the shift vectors
        shifted_x = []
        shifted_y = []
        if catalog['THETA_IMAGE'].unit.name == 'deg':
            translate = True
        elif catalog['THETA_IMAGE'].unit.name == 'rad':
            translate = False
        else:
            raise aXeError("Unknown unit on THETA_IMAGE in input catalog")

        for i, (x, y, t) in enumerate(zip(catalog['X_IMAGE'],
                                          catalog['Y_IMAGE'],
                                          catalog['THETA_IMAGE'])):
            # compute shift vector
            if translate:
                trad = t * math.pi / 180.0

            # 10.0 is a made up length to use?
            shifted_x.append(x + 10.0 * math.cos(trad))
            shifted_y.append(y + 10.0 * math.sin(trad))

        for row in range(len(catalog)-1, -1, -1):
            # extract the projected object positions
            x_ori = dither_image_xy[0][row]
            y_ori = dither_image_xy[1][row]

            # check whether the object position is
            # in the range to be stored
            if ((x_ori >= self.dim_info[0] and x_ori <= self.dim_info[1]) and \
               (y_ori >= self.dim_info[2] and y_ori <= self.dim_info[3])):

                # compute the new object angle
                dx = shifted_x[row] - x_ori
                dy = shifted_y[row] - y_ori
                angle = math.atan2(dy, dx) * (180. / math.pi)  # compute local angle

                # fill in the new position and angle
                catalog['X_IMAGE'][row] = x_ori
                catalog['Y_IMAGE'][row] = y_ori
                catalog['THETA_IMAGE'][row] = angle

            else:
                catalog.remove_row(row)

        # save the new IOL, this is done especially for the C
        # code which is expecting Source Extractor style catalog
        # files. Decided to keep the output here consistent with
        # the C code so that it can continue to be used separately.
        # numbers start at 1 not zero. The output formatting allows
        # the astropy.sextractor formatter to read the catalog file.
        # There isn't currently an astropy writer for that format.
        if os.access(self.iol_name, os.F_OK):
            os.remove(self.iol_name)
        of = open(self.iol_name, 'w')
        for num, name in zip(range(len(catalog.colnames)), catalog.colnames):
            of.write("# {0:d} {1:s}\t\t{2:s}\t\t[{3:s}]\n".format(num+1,
                                                                  name,
                                                                  catalog[name].description,
                                                                  str(catalog[name].unit))
                                                                 )
        catalog.write(of, format='ascii.no_header', overwrite=False)
        of.close()

        print("\n >>>> Catalog: {0:s} written with {1:d} entries.>>>> \n"
              .format(self.iol_name, len(catalog)))


class IOLMaker:
    """Central class to take the input and to create Input Object Lists

    for the list of images extracted from the header of the
    drizzled image.
    """
    def __init__(self, drizzle_image, input_cat,  dim_term):
        """
        Parameters
        ----------
        drizzle_image: str
            the name of the drizzled image
        input_cat: str
            the name of the input catalogue made
            from the drizzled image, the master catalog
        dim_term:
            description of the additional rows/column for the
            Input Object Lists

        Returns
        -------
        Nothing

        Notes
        -----
        The class data is set. While doing that, basic checks
        on the input is done. The existence of the images is
        checked, also the data type of the various real
        or integer numbers.
        """
        self.iol_list = []
        self.dim_info = []

        # check whether the drizzled image exists,
        # store the name if it exists
        if not os.access(drizzle_image, os.F_OK):
            err_msg = "File: {0:s} does not exist!".format(drizzle_image)
            raise aXeError(err_msg)
        else:
            self.drizzle_image = drizzle_image

        # check whether the input catalogue exists,
        # store the name if it exists
        if not os.path.isfile(input_cat):
            err_msg = 'File: ' + input_cat + ' does not exist!'
            raise aXeError(err_msg)
        else:
            self.input_cat = Table.read(input_cat,
                                        format='ascii.sextractor')

        # resolve and get the dimension information
        self._set_dimension_info(dim_term)

        # create the list of Input Object Instances
        self._fill_iollist()

    def _set_dimension_info(self, dimension_term):
        """Get the dimension information"""
        # initialize the array

        # check the dimension input
        dim_entries = dimension_term.split(',')

        # is the number of items correct?
        if len(dim_entries) != 4:
            err_msg = ("There must be 4 entries in the term: {0:s},"
                       "not {1:d}!".format(dimension_term, len(dim_entries)))
            raise aXeError(err_msg)

        # check whether each item is an integer
        for item in dim_entries:
            try:
                int_item = int(item.strip())
            except ValueError:
                raise aXeError("Item: {} must be integer!".format(item))

            # store the item
            self.dim_info.append(int_item)

    def _fill_iollist(self):
        """Derive the names for the input parameters from input images.

        The method derives the names for the input
        images from the header of the drizzled images
        and then creates an Input Object List instance
        for each input image.

        Returns
        -------
        iolists: list
            the list of new IOL instances

        Returns
        -------
        The list with the IOL instances.

        """

        # determine the number of iput images
        n_iols = self._get_niol()

        drizzle_head = fits.getheader(self.drizzle_image, ext=0)

        # for each input image
        for index in range(1, n_iols+1):

            # extract the name
            keyname = 'D%03iDATA' % (index)

            # create a new IOl instance at the end of the list
            self.iol_list.append(ProjectionList(drizzle_head[keyname],
                                                self.dim_info))

    def _get_niol(self):
        """Return the number of input images from the header
        Parameters
        ----------
        None

        Returns
        -------
        ID: int
            The number of input images

        Notes
        -----
        The method looks in the header of the drizzled image
        for the name of the input images used in the drizzle
        process. This number is returned
        """
        # open the fits file and get the header
        drizzle_head = fits.getheader(self.drizzle_image, ext=0)

        # create the keyname for the first input image
        ID = 1
        keyname = "D{0:03d}DATA".format(ID)

        # create the keyname for subsequent input images
        # and continue until the keynames do not exist
        while keyname in drizzle_head:
            ID = ID+1
            keyname = "D{0:03d}DATA".format(ID)

        # correct the number
        ID = ID-1

        # return the number
        return ID

    def run(self):
        """Create the Input Object Lists.

        This method is responsible for creating the
        Input Object Lists. Other internal methods as well as
        methods of other classes are successively
        called to create the Input Object Lists associated with the
        input images listed in the header of the
        drizzled image.


        Parameters
        ----------
        None

        Returns
        -------
        Nothing
        """

        # create the new Input Object Lists
        for iol in self.iol_list:
            # make a new IOL for each input image
            iol.make_grismcat(self.drizzle_image, deepcopy(self.input_cat))
